`DOMContentLoaded` — це подія в JavaScript, яка спрацьовує, коли HTML-документ повністю завантажений і розпарсений, але зовнішні ресурси, як-от стилі чи зображення, ще можуть завантажуватися. Це дуже корисна подія для виконання скриптів, оскільки вам не потрібно чекати завантаження всіх ресурсів, щоб маніпулювати DOM.

Основні моменти:
- `DOMContentLoaded` спрацьовує, коли браузер завершує побудову HTML-документа.
- Це швидше, ніж очікування події `load`, яка спрацьовує тільки після завантаження всіх ресурсів, включаючи зображення та стилі.

Приклад використання:
```javascript
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM повністю завантажено і розпарсено');
  // Ваш код для маніпуляції DOM
});
```

Це корисно, коли ви хочете почати роботу з елементами DOM якомога раніше, не чекаючи завантаження усіх ресурсів на сторінці.

Так, подія, про яку ви згадуєте, називається `load`. Вона також пов'язана з моментом завершення завантаження сторінки, але є кілька важливих відмінностей від `DOMContentLoaded`.

Подія `load` спрацьовує тоді, коли вся сторінка повністю завантажена, включаючи всі зовнішні ресурси, такі як зображення, стилі, скрипти тощо. Це означає, що браузер завершує завантаження як HTML-документа, так і всіх підключених ресурсів.

Основні моменти:
- `load` виконується пізніше, ніж `DOMContentLoaded`, оскільки очікує завантаження всіх ресурсів.
- Часто використовується для виконання скриптів, які залежать від повного завантаження сторінки, зокрема для роботи з ресурсами, що не є частиною DOM (наприклад, зображення чи фрейми).

Приклад використання:
```javascript
window.addEventListener('load', function() {
  console.log('Сторінка повністю завантажена');
  // Ваш код для виконання після повного завантаження сторінки
});
```

Різниця між цими подіями:
- `DOMContentLoaded` дозволяє виконати скрипти одразу після побудови DOM, не чекаючи на завантаження всіх ресурсів.
- `load` очікує завантаження абсолютно всіх ресурсів на сторінці.

Таким чином, якщо вам потрібно лише взаємодіяти з DOM, краще використовувати `DOMContentLoaded`. Якщо ж ваш скрипт потребує повного завантаження сторінки (наприклад, для роботи із зображеннями), тоді доцільно використовувати `load`.

В JavaScript є багато подій, які можуть спрацьовувати в DOM. Коли користувач взаємодіє з елементами сторінки, такими як кнопки, форми чи посилання, можуть виникати різні події. Давайте розглянемо основні варіанти подій та приклади, що стосуються кліків по кнопці:

### 1. **Клік (click)**
   Подія `click` спрацьовує, коли користувач клацає на елемент, наприклад на кнопку.
   
   ```javascript
   const button = document.querySelector('button');
   button.addEventListener('click', function() {
     console.log('Кнопка натиснута');
   });
   ```

### 2. **Подвійний клік (dblclick)**
   Подія `dblclick` спрацьовує, коли користувач робить подвійний клік по елементу.

   ```javascript
   const button = document.querySelector('button');
   button.addEventListener('dblclick', function() {
     console.log('Кнопка натиснута двічі');
   });
   ```

### 3. **Затиснення кнопки (mousedown)**
   Подія `mousedown` спрацьовує, коли користувач натискає кнопку миші на елементі, але ще не відпускає її.

   ```javascript
   const button = document.querySelector('button');
   button.addEventListener('mousedown', function() {
     console.log('Кнопка миші затиснута на кнопці');
   });
   ```

### 4. **Відпускання кнопки (mouseup)**
   Подія `mouseup` спрацьовує, коли користувач відпускає кнопку миші після її натискання на елементі.

   ```javascript
   const button = document.querySelector('button');
   button.addEventListener('mouseup', function() {
     console.log('Кнопка миші відпущена на кнопці');
   });
   ```

### 5. **Наведення курсору (mouseenter і mouseleave)**
   - `mouseenter` спрацьовує, коли курсор заходить на елемент.
   - `mouseleave` спрацьовує, коли курсор виходить з елемента.

   ```javascript
   const button = document.querySelector('button');
   button.addEventListener('mouseenter', function() {
     console.log('Курсор наведений на кнопку');
   });
   button.addEventListener('mouseleave', function() {
     console.log('Курсор покинув кнопку');
   });
   ```

### 6. **Фокус і розфокус (focus і blur)**
   - `focus` спрацьовує, коли елемент (наприклад, поле введення) стає активним.
   - `blur` спрацьовує, коли елемент втрачає фокус.

   ```javascript
   const input = document.querySelector('input');
   input.addEventListener('focus', function() {
     console.log('Поле вводу у фокусі');
   });
   input.addEventListener('blur', function() {
     console.log('Поле вводу втратило фокус');
   });
   ```

### 7. **Зміна значення (input і change)**
   - `input` спрацьовує при кожній зміні значення в елементі введення.
   - `change` спрацьовує після завершення зміни (наприклад, коли поле втрачає фокус після зміни значення).

   ```javascript
   const input = document.querySelector('input');
   input.addEventListener('input', function() {
     console.log('Значення змінюється: ', input.value);
   });
   input.addEventListener('change', function() {
     console.log('Значення змінено: ', input.value);
   });
   ```

### 8. **Клавіатурні події (keydown, keyup, keypress)**
   - `keydown` спрацьовує, коли користувач натискає клавішу.
   - `keyup` — коли клавіша відпускається.
   - `keypress` — коли натискається клавіша, яка генерує символ (deprecated, краще використовувати `keydown` або `keyup`).

   ```javascript
   document.addEventListener('keydown', function(event) {
     console.log('Клавіша натиснута: ', event.key);
   });
   document.addEventListener('keyup', function(event) {
     console.log('Клавіша відпущена: ', event.key);
   });
   ```

### Підсумок
Взаємодія користувача з DOM може генерувати безліч подій. Залежно від типу взаємодії, можна слухати та обробляти такі події, як кліки, введення тексту, переміщення курсору тощо. Для кнопок найчастіше використовують подію `click`, але ви також можете використовувати інші події, щоб відстежувати різні взаємодії користувачів.

В DOM події розповсюджуються (або «поширюються») через різні елементи за допомогою двох основних фаз: **event capturing (захоплення події)** та **event bubbling (спливаюча подія)**. Обидві фази описують, як подія переміщується через DOM-дерево.

### 1. **Event Bubbling (спливаюча подія)**
   Це фаза, під час якої подія починає свій шлях з найвнутрішнього елемента і піднімається вгору через DOM до кореня документа. Тобто, коли користувач взаємодіє з внутрішнім елементом (наприклад, кнопкою), подія "бульбашиться" вгору до його батьківських елементів.

   **Приклад:**
   ```html
   <div id="parent">
     <button id="child">Натисни мене</button>
   </div>

   <script>
     document.getElementById('parent').addEventListener('click', function() {
       console.log('Подія на батьківському елементі');
     });

     document.getElementById('child').addEventListener('click', function() {
       console.log('Подія на кнопці');
     });
   </script>
   ```

   У цьому прикладі, коли ви натискаєте на кнопку, подія спочатку спрацьовує на кнопці (виводиться текст «Подія на кнопці»), а потім піднімається вгору до `div`, що оточує кнопку (виводиться текст «Подія на батьківському елементі»).

### 2. **Event Capturing (захоплення події)**
   У фазі захоплення подія починає свій шлях з найвищого рівня DOM-дерева (від кореня документа) і переміщується до найвнутрішнього елемента, на якому сталася подія. Події захоплюються згори донизу.

   Щоб активувати прослуховування події на етапі захоплення, потрібно вказати третій параметр методу `addEventListener` як `true`.

   **Приклад з захопленням:**
   ```html
   <div id="parent">
     <button id="child">Натисни мене</button>
   </div>

   <script>
     document.getElementById('parent').addEventListener('click', function() {
       console.log('Подія на батьківському елементі (захоплення)');
     }, true);

     document.getElementById('child').addEventListener('click', function() {
       console.log('Подія на кнопці');
     });
   </script>
   ```

   В цьому випадку спочатку спрацює обробник для батьківського елемента `div` (на фазі захоплення), і лише потім для кнопки, оскільки подія рухається згори вниз.

### Три фази розповсюдження події:
1. **Capturing (Захоплення)**: Подія проходить від кореневого елемента (наприклад, `document`) до найвнутрішнього елемента.
2. **Target (Цільова фаза)**: Подія досягає елемента, на якому сталася дія.
3. **Bubbling (Спливаюча подія)**: Подія поширюється від елемента, де вона виникла, вгору по DOM-дереву.

### Методи для контролю розповсюдження подій:
1. **`stopPropagation()`**
   Використовується для припинення подальшого розповсюдження події по DOM-дереву. Якщо викликати цей метод, подія не перейде далі на батьківські елементи.

   **Приклад:**
   ```javascript
   document.getElementById('child').addEventListener('click', function(event) {
     console.log('Подія на кнопці');
     event.stopPropagation(); // Зупиняє розповсюдження події
   });

   document.getElementById('parent').addEventListener('click', function() {
     console.log('Подія на батьківському елементі');
   });
   ```

   У цьому прикладі, після натискання на кнопку, подія не підніметься до батьківського елемента через `stopPropagation()`.

2. **`stopImmediatePropagation()`**
   Зупиняє не тільки поширення події по DOM-дереву, але й будь-які інші обробники події для цього елемента, які ще не були викликані.

   **Приклад:**
   ```javascript
   document.getElementById('child').addEventListener('click', function(event) {
     console.log('Цей обробник спрацює');
     event.stopImmediatePropagation(); // Зупиняє всі інші обробники
   });

   document.getElementById('child').addEventListener('click', function() {
     console.log('Цей обробник не спрацює');
   });
   ```

3. **`preventDefault()`**
   Цей метод використовується для відміни стандартної поведінки елемента (наприклад, відміна переходу по посиланню або відправки форми).

   **Приклад:**
   ```javascript
   const link = document.querySelector('a');
   link.addEventListener('click', function(event) {
     event.preventDefault(); // Відміняє перехід по посиланню
     console.log('Посилання заблоковане');
   });
   ```

### Підсумок
- **Event bubbling**: Подія починається з цільового елемента і піднімається вгору до батьківських елементів.
- **Event capturing**: Подія починається з кореневого елемента і рухається до цільового.
- Ви можете контролювати розповсюдження подій за допомогою методів `stopPropagation()`, `stopImmediatePropagation()`, та `preventDefault()`.


За замовчуванням у браузерах використовується **event bubbling** (спливаюча подія). Це означає, що коли ви додаєте обробник події за допомогою методу `addEventListener()`, подія спочатку спрацьовує на цільовому елементі, а потім піднімається вгору по DOM-дереву до його батьківських елементів.

Приклад:
```javascript
document.getElementById('child').addEventListener('click', function() {
  console.log('Подія на кнопці');
});

document.getElementById('parent').addEventListener('click', function() {
  console.log('Подія на батьківському елементі');
});
```

У цьому випадку, якщо ви натиснете кнопку, подія спершу спрацює на кнопці (виведеться "Подія на кнопці"), а потім "бульбашитиметься" вгору до батьківського елемента (виведеться "Подія на батьківському елементі").

Щоб змінити це і використати фазу **event capturing** (захоплення події), необхідно передати третій параметр `true` у метод `addEventListener()`:
```javascript
document.getElementById('parent').addEventListener('click', function() {
  console.log('Подія на батьківському елементі (захоплення)');
}, true);
```

Отже, основний варіант по замовчуванню — це **event bubbling**, якщо не вказано інше.